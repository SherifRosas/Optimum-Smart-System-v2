import pytest
from datetime import date, timedelta
from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order




from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order


from orders.serializers import OrderSerializer
from orders.models import Order
from customers.models import Customer
from suppliers.models import Supplier
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
def customer():
    return Customer.objects.create(
        name='Test Customer',
        phone_number='1234567890',
        email='customer@example.com'
    )


@pytest.fixture
def supplier():
    return Supplier.objects.create(
        name='Test Supplier',
        email='supplier@example.com',
        phone_number='0987654321',
        contact_person='John Doe',
        address='123 Main St',
        is_active=True
    )


@pytest.mark.django_db
class TestOrderSerializer:
    def test_product_type_sanitization(self, customer, supplier):
        """Test that product type is sanitized"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '<script>alert("xss")</script>Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Check that script tags are removed (sanitize_text removes HTML tags)
        sanitized = serializer.validated_data['product_type']
        assert '<script>' not in sanitized
        assert '</script>' not in sanitized
        # HTML entities are escaped, which is correct behavior

    def test_product_type_validation(self, customer, supplier):
        """Test product type validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': '',  # Empty
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'product_type' in serializer.errors

    def test_quantity_validation(self, customer, supplier):
        """Test quantity validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 0,  # Invalid
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'quantity' in serializer.errors

    def test_unit_price_validation(self, customer, supplier):
        """Test unit price validation"""
        future_date = date.today() + timedelta(days=30)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': -10.00,  # Invalid
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'unit_price' in serializer.errors

    def test_delivery_date_validation(self, customer, supplier):
        """Test delivery date validation"""
        past_date = date.today() - timedelta(days=1)
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': past_date,  # Invalid
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert not serializer.is_valid()
        assert 'delivery_date' in serializer.errors

    def test_cross_field_validation(self, customer, supplier):
        """Test cross-field validation for total amount"""
        future_date = date.today() + timedelta(days=30)
        # Note: total_amount is read_only, so it's ignored in validation
        # The validation happens in the validate() method but only if total_amount is in data
        # Since it's read_only, we can't test it directly, but we can verify the calculation
        data = {
            'customer_id': customer.id,
            'supplier_id': supplier.id,
            'product_type': 'Test Product',
            'quantity': 10,
            'unit_price': 100.00,
            'delivery_date': future_date,
            'status': 'pending'
        }
        serializer = OrderSerializer(data=data)
        assert serializer.is_valid()
        # Verify that total would be calculated correctly (100 * 10 = 1000)
        # This is tested implicitly when creating an order

